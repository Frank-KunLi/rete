#第二章 基本Rete算法

既然本论文的大部分工作都以Rete匹配算法为基础，本章主要描述Rete算法。不幸的是，大多数文献中对Rete算法的描述都不够特别明晰，
这也许是Rete被冠以`极度难懂`的帽子的原因（Perlin，1990b）。为了扭转这种形势，本章将以教程的形式描述Rete，而不是简略地回顾
一下并引导读者去看完整描述的文献资料。我们首先大体上看一下Rete，然后讨论数据结构和一般情况下实现程序的原则，这就是本章可以
给想在他们自己系统中实现Rete算法或变体的读者的一个指导。已经熟悉Rete或者想了解本论文研究贡献的人可以跳过本章。2.6节和下面
的章节讨论Rete的高级特性，第一性阅读时也可以跳过，本篇论文剩余的大部分没有它们也可以理解。

在开始我们的Rete讨论之前，先回顾下一些基本的术语和记法。Rete（通常发音为`REET`或者`REE-tee`，源自拉丁语中网络的意思）涉及
生产区（Production Memeory，简称PM）和工作区（Working Memory，简称WM）。它们中的每一个随着时间可以逐渐地改变。工作区是一组
代表系统当前形势的事实（Fact）--外部世界的状态和（或者）系统自己内部要解决问题的状态。WM中每个元素被叫做工作区元素（Working
Memory Element,简称WME）。在`积木世界`系统里，比如说，工作区也许由下面的WMEs（记为w1-w9.）组成：
<pre><code>
w1:(B1 ^on B2)
w2:(B1 ^on B3)
w3:(B1 ^color red)
w4:(B2 ^on table)
w5:(B2 ^left-of B3)
w6:(B2 ^color blue) 
w7:(B3 ^left-of B4)
w8:(B3 ^on table) 
w9:(B3 ^color red) 
</code></pre>

为了简化我们的描述，我们会假设WMEs是三元组的形式，把它们写成`(identifier ^attribute value)`。“identifier","attribute","value"
对匹配器来说没有特殊的含义。我们有时把”identifier"缩写成`id`，”attribute“缩写成`attr`。我们会把这部分作为一个WME的三个域，
比如WME(B1 ^on B2)有B1在它的id域里。每个域包含一个符号。什么符号是被允许的唯一约束是它们都必须是常量：WMEs中不允许有变量。
Rete不要求特殊表示--众多的Rete版本中支持其它已经实现的表示，我们会在2.11节讨论这些。在这里我们选择该特殊形式是因为：
* 它非常简单
* 对WMEs这种形式的约束并没有带来表示能力的丧失，由于其它更少约束的表示能够被直接地、机械地转换成这种形式，我们会在2.11节看到它
* 试验台系统在本论文中随后描述使用这种表示

生产区（PM）是一组生产（或者叫规则，rules）。一条规则被指定为一组条件（conditions）,共同被称为左边（left-hand side，LHS），
和一组行为（Actioins），共同被称为右手边（Right-hand Side）。规则通常以下面的形式写成：
<pre><code>
 (name-of-this-production
   LHS  /* 一个或多个条件*/
  -->
   RHS  /* 一个或多个行为 */
 )
</code></pre>

匹配算法通常会忽略行为只处理条件。匹配算法作为一个模块或者子程序被整个系统使用以确定哪个规则的所有条件都是满足的，然后系统的
一些其它部分处理合适的规则的行为。因此，本章将会聚焦在条件上。条件可以包含变量，我们把它写在尖括号里，比如：<x>。在我们的
”积木世界“例子中，下面的规则可以被用作的查找红方块左边两个或更多的方块：
<pre><code>
(find-stack-of-two-blocks-to-the-left-of-a-red-block
  (<x> ^on <y>)
  (<y> ^left-of <z>)
  (<z> ^color red)
 -->
  ... RHS ...
)
</code></pre>

图2.1：做为黑盒子的Rete算法的输入输出

如果一条规则的所有条件匹配上了当前工作区里的所有元素，并且条件中的任意变量始终绑定，那么规则被称作匹配当前工作区。比如，
上面的的规则匹配上了上面的工作区，因为它的三个条件被w1、w5、w9分别匹配上，<y>绑定到B2在第一个和第二个条件中，<z>绑定到B3
在第二和第三个条件上。该匹配算法的工作是确定哪个系统中的哪个规则匹配上当前的工作区，并且对每一个，确定哪个一个WME匹配哪个
条件。请注意既然我们假设WMEs都是三元组，我们也能假设条件有同样的形式--一个非该形式的条件永远不会匹配上任何WME，也就是说
它是无用的。

如图2.1所示，Rete被视作一个`黑盒子`。作为输入，它获取对当前工作区的变更信息（例如，增加WME）或者一组规则（例如，增加规则）。
每次它被通知其中一个变化，匹配算法必须输出对匹配规则集的任意改变（比如，现在规则匹配上了这些WMEs）。

##2.1 概览
我们开始对Rete做一个简短的概览。如图2.2所示，Rete用一个数据流网络表示规则的条件。这个网络有两部分。Alpha部分执行常量测试
在WME上（测试像red和left-of这样的常量标识）。它的输出被存储在`alpha存储区`（AM），每一个AM持有通过所有常量测试的个体条件的
当前WME集合。例如，在图示中，第一个条件(<x> ^on <y>)的AM，持有属性域包含符号`on`的WMEs。alpha网络的实现在2.2节讨论。网络
的beta部分首要包含`join节点`和`beta存储区`（随后我们讨论几种其它的节点类型）。`Join节点`绑定在条件之间的变量一致性的测试。Beta
存储区部分规则的实例（例如，匹配规则部分而非全部条件的WME组合）。这些部分实例被称作`tokens`。

图2.2 Rete网络示例，(a)几条规则，（b）一条规则的实例化网络

严格地说，在Rete的大部分版本中，alpha网络不仅执行常量测试并且也执行内部条件变量绑定一致性测试，此时一个变量在一个单独的
条件中出现多于一次，比如，(<x> ^self <x>)。这样的测试在Soar中很少见，因此我们不在这里做过多的讨论。同时，注意`测试`实际
上可以是任何布尔值的函数。在Soar中，大部分测试是相等测试（检查一件事件是否等于另外一件），因此我们在这里主要侧重在这种
情况。无论如何，Rete的实现通常至少支持简单的条件测试（大于，小于，等等），一些版本允许任意用户自定义的测试。任何实现中，
基本思路是alpha网络执行包含单个WME的所有测试，而beta网络执行包含两个或两个以上WME的测试。

和关系数据库的类比也许是有帮助的。把当前的工作区当作一个列表，每条规则当作一个查询。在一个条件中的常量测试表示在WM
列表作`SELECT`操作。对系统中的每一个不同的条件Ci，alpha存储区存储`SELECT`的结果R(Ci)。现在，用P表示包含条件C1,...,Ck，
P和当前工作区的匹配结果（如果P有任何的匹配）表示为R(C1) & ... & R(Ck)，`JOIN`操作执行合适的变量绑定一致性检查。rete网络
的beta部分中的join节点执行这些join操作，同时每个beta存储区存储其中一个中间join的结果 R(c1) & ... & R(Ci) (i<k)。

无论何时工作区发生变更，我们更新这些`SELECT`和`JOIN`结果。步骤如下：工作区变更通过alpha网络被发送出去同时相应的alpha存储区
被更新。然后这些变更被传递给相连的join节点，并`激活`这些节点。如果任何新的部分实例被创建，他们被添加到相应的beta存储区然后
被向下传递到网络的beta部分，激活其它的节点。每当传递达到网络的最底层，它表明一条规则的条件被完全匹配到。这个通常靠
在网络底层定义一个规则（p-node）的特殊节点来实现。每当p-node被激活，它意味着一个新的发现匹配完成（在一些系统相关的方法）。

Rete算法的大部分代码是由处理各种节点激活的程序组成。一个alpha存储区节点的激活靠添加一个给定的WME到存储区来处理，然后传递
WME到存储区的继承者（Join节点会连接它）。相似地，beta存储区节点的激活靠添加一个给定的token到存储区来处理然后把它传递到该
节点的子节点（join节点）。总的来说，beta网络中从一个节点到另外一个节点的激活被称作`左激活`（left activation），来自alpha
存储区的节点的激活被称作`右激活`（right activation）。因此，一个join节点能够招致两种类型的激活：当一个WME被添加到它的alpha
存储区的右激活，和一个token被添加到beta存储区的左激活。左右join节点激活通常在两个不同的程序里实现，但在这两种情况下，都搜索
节点的其它存储区是否存在和新元素有同样变量绑定的元素，如果有发现，它们将被传向join节点的子节点。

为了激活一个给定的节点，那么我们使用一个程序调用。这个特殊的程序依赖于节点的类型，比如，beta存储区节点的左激活被一个程序
处理，另外一个不同的程序处理join节点的左激活。为了从某一节点传递数据流到它的继承者，我们迭代这些继承者并且为每个调用适合
的激活程序。我们靠 查找节点的类型来确认哪一个程序是适合的：我们使用switch或者case表达式取决于节点类型，每个分支调用一个不
同的程序，或者我们通过一个根据节点类型进行索引的跳转表来作程序调用。（为了效率有些编译器把switch表达式转成跳转表）。

Rete有两个重要的特性使之比原生匹配算法要快的多。第一个是`状态保存`。每一次对WM的变更，匹配的状态（结果）被保存在alpha和
beta存储区。在WM再次变更后，很多或大部分结果通常是没有变化的，因此Rete靠保持成功WM变化间的结果避免了很重复计算。（Rete为
这样的系统而设计，在连续匹配的规则上有很少的WME变更。Rete的状态保存在WME每次都改变的系统中不是很有用）。

Rete的每二个重要的特性是在具有相似条件的规则间的`节点共享`。不同类别的共享出现在网络的不同部分。在alpha网络中的共享，如
2.2节讨论的。对alpha网络的输出，当两个或以上规则有同样的条件，Rete只使用一个AM来存储这些条件，而不是为每一个条件创建重复
的存储区。例如，在图2.2(a)中，C3的AM被规则P1和P3所共享。此外，在网络的beta部分，当两个或以上的规则第一次有相同的少量条件
时，同一节点被来匹配这些条件。这避免了这些规则的重复匹配。在图示中，三个规则胡相同的前两个条件，二个规则有相同的前三个条
件。因为共享，beta部分构成了一棵树。

Rete的实现可以解释或编译。在解释版本中，网络的描述仅被简单地存储为解释器可以执行的数据结构。在编译版本中，网络不是被显式
地表示，而是被一组程序代替，通常一个节点一个或两个程序。比如，一个解释版本要提交一个通用的"left-activation-of-join-node"
程序到一个特殊的join节点（靠把程序的指针指向节点的数据结构），编译版本靠考虑特殊节点部分地评估解释器的通用程序来创建一个
特殊的程序（本章会描述通用解释器程序）。编译版本的优势当然是更快的速度。它的缺点一是需要更大的存储空间（一个节点的编译
程序通常比解释的数据结果占用更多的空间），二是运行时程序很难添加或者删除（修改编译过的代码比修改一个解释的数据结构难多了
--尽管至少一个编译版本解决了这个问题）。

在本章的剩余部分，我们将更深入地描述Rete，为它的基本数据结构和程序给出高级伪代码。这些伪代码会一节一节地给出，为了增加一
个在后续章节才会被讨论的特殊的支持，有时更靠后的章节会修订之前给出的。一个完整版本的伪代码，包括一些在后面章节介绍的重要
改进，会放在附录A里。

一个系统的Rete模块有四个入口点：`add-wme`，`remove-wme`，`add-production`和`remove-production`。我们先从add-wme的调用开始
讨论：2.2节alpha网络做什么，2.3节描述alpha和beta存储区节点做什么，2.4节描述join节点做什么。我们将在2.5节讨论remove-wme，
2.6节讨论add-production和remove-production。接下来我们将讨论一些Rete更复杂的特性：2.7节展示了如何处理否定条件（测试WME的
不存在），2.8节展示否定结合（测试WME组合的不存在）如何被处理的。然后我们在2.9节给出几种实现说明，并在2.10节纵览一些过去
这些年其它一些Rete的优化。最后，在2.11节讨论一下Rete算法的普遍性，包含它对更少WME限制表示的适应性。

 