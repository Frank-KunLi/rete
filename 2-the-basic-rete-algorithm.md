#第二章 基本Rete算法

既然本论文的大部分工作都以Rete匹配算法为基础，本章主要描述Rete算法。不幸的是，大多数文献中对Rete算法的描述都不够特别明晰，
这也许是Rete被冠以`极度难懂`的帽子的原因（Perlin，1990b）。为了扭转这种形势，本章将以教程的形式描述Rete，而不是简略地回顾
一下并引导读者去看完整描述的文献资料。我们首先大体上看一下Rete，然后讨论数据结构和一般情况下实现程序的原则，这就是本章可以
给想在他们自己系统中实现Rete算法或变体的读者的一个指导。已经熟悉Rete或者想了解本论文研究贡献的人可以跳过本章。2.6节和下面
的章节讨论Rete的高级特性，第一性阅读时也可以跳过，本篇论文剩余的大部分没有它们也可以理解。

在开始我们的Rete讨论之前，先回顾下一些基本的术语和记法。Rete（通常发音为`REET`或者`REE-tee`，源自拉丁语中网络的意思）涉及
生产区（Production Memeory，简称PM）和工作区（Working Memory，简称WM）。它们中的每一个随着时间可以逐渐地改变。工作区是一组
代表系统当前形势的事实（Fact）--外部世界的状态和（或者）系统自己内部要解决问题的状态。WM中每个元素被叫做工作区元素（Working
Memory Element,简称WME）。在`积木世界`系统里，比如说，工作区也许由下面的WMEs（记为w1-w9.）组成：
<pre><code>
w1:(B1 ^on B2)
w2:(B1 ^on B3)
w3:(B1 ^color red)
w4:(B2 ^on table)
w5:(B2 ^left-of B3)
w6:(B2 ^color blue) 
w7:(B3 ^left-of B4)
w8:(B3 ^on table) 
w9:(B3 ^color red) 
</code></pre>

为了简化我们的描述，我们会假设WMEs是三元组的形式，把它们写成`(identifier ^attribute value)`。“identifier","attribute","value"
对匹配器来说没有特殊的含义。我们有时把”identifier"缩写成`id`，”attribute“缩写成`attr`。我们会把这部分作为一个WME的三个域，
比如WME(B1 ^on B2)有B1在它的id域里。每个域包含一个符号。什么符号是被允许的唯一约束是它们都必须是常量：WMEs中不允许有变量。
Rete不要求特殊表示--众多的Rete版本中支持其它已经实现的表示，我们会在2.11节讨论这些。在这里我们选择该特殊形式是因为：
* 它非常简单
* 对WMEs这种形式的约束并没有带来表示能力的丧失，由于其它更少约束的表示能够被直接地、机械地转换成这种形式，我们会在2.11节看到它
* 试验台系统在本论文中随后描述使用这种表示

生产区（PM）是一组生产（或者叫规则，rules）。一条规则被指定为一组条件（conditions）,共同被称为左边（left-hand side，LHS），
和一组行为（Actioins），共同被称为右手边（Right-hand Side）。规则通常以下面的形式写成：
<pre><code>
 (name-of-this-production
   LHS  /* 一个或多个条件*/
  -->
   RHS  /* 一个或多个行为 */
 )
</code></pre>

匹配算法通常会忽略行为只处理条件。匹配算法作为一个模块或者子程序被整个系统使用以确定哪个规则的所有条件都是满足的，然后系统的
一些其它部分处理合适的规则的行为。因此，本章将会聚焦在条件上。条件可以包含变量，我们把它写在尖括号里，比如：<x>。在我们的
”积木世界“例子中，下面的规则可以被用作的查找红方块左边两个或更多的方块：
<pre><code>
(find-stack-of-two-blocks-to-the-left-of-a-red-block
  (<x> ^on <y>)
  (<y> ^left-of <z>)
  (<z> ^color red)
 -->
  ... RHS ...
)
</code></pre>

图2.1：做为黑盒子的Rete算法的输入输出

如果一条规则的所有条件匹配上了当前工作区里的所有元素，并且条件中的任意变量始终绑定，那么规则被称作匹配当前工作区。比如，
上面的的规则匹配上了上面的工作区，因为它的三个条件被w1、w5、w9分别匹配上，<y>绑定到B2在第一个和第二个条件中，<z>绑定到B3
在第二和第三个条件上。该匹配算法的工作是确定哪个系统中的哪个规则匹配上当前的工作区，并且对每一个，确定哪个一个WME匹配哪个
条件。请注意既然我们假设WMEs都是三元组，我们也能假设条件有同样的形式--一个非该形式的条件永远不会匹配上任何WME，也就是说
它是无用的。

如图2.1所示，Rete被视作一个`黑盒子`。作为输入，它获取对当前工作区的变更信息（例如，增加WME）或者一组规则（例如，增加规则）。
每次它被通知其中一个变化，匹配算法必须输出对匹配规则集的任意改变（比如，现在规则匹配上了这些WMEs）。

##2.1 概览
我们开始对Rete做一个简短的概览。如图2.2所示，Rete用一个数据流网络表示规则的条件。这个网络有两部分。Alpha部分执行常量测试
在WME上（测试像red和left-of这样的常量标识）。它的输出被存储在`alpha存储区`（AM），每一个AM持有通过所有常量测试的个体条件的
当前WME集合。例如，在图示中，第一个条件(<x> ^on <y>)的AM，持有属性域包含符号`on`的WMEs。alpha网络的实现在2.2节讨论。网络
的beta部分首要包含`join节点`和`beta存储区`（随后我们讨论几种其它的节点类型）。`Join节点`绑定在条件之间的变量一致性的测试。Beta
存储区部分规则的实例（例如，匹配规则部分而非全部条件的WME组合）。这些部分实例被称作`tokens`。

图2.2 Rete网络示例，(a)几条规则，（b）一条规则的实例化网络

严格地说，在Rete的大部分版本中，alpha网络不仅执行常量测试并且也执行内部条件变量绑定一致性测试，此时一个变量在一个单独的
条件中出现多于一次，比如，(<x> ^self <x>)。这样的测试在Soar中很少见，因此我们不在这里做过多的讨论。同时，注意`测试`实际
上可以是任何布尔值的函数。在Soar中，大部分测试是相等测试（检查一件事件是否等于另外一件），因此我们在这里主要侧重在这种
情况。无论如何，Rete的实现通常至少支持简单的条件测试（大于，小于，等等），一些版本允许任意用户自定义的测试。任何实现中，
基本思路是alpha网络执行包含单个WME的所有测试，而beta网络执行包含两个或两个以上WME的测试。

和关系数据库的类比也许是有帮助的。把当前的工作区当作一个列表，每条规则当作一个查询。在一个条件中的常量测试表示在WM
列表作`SELECT`操作。对系统中的每一个不同的条件Ci，alpha存储区存储`SELECT`的结果R(Ci)。现在，用P表示包含条件C1,...,Ck，
P和当前工作区的匹配结果（如果P有任何的匹配）表示为R(C1) & ... & R(Ck)，`JOIN`操作执行合适的变量绑定一致性检查。rete网络
的beta部分中的join节点执行这些join操作，同时每个beta存储区存储其中一个中间join的结果 R(c1) & ... & R(Ci) (i<k)。

无论何时工作区发生变更，我们更新这些`SELECT`和`JOIN`结果。步骤如下：工作区变更通过alpha网络被发送出去同时相应的alpha存储区
被更新。然后这些变更被传递给相连的join节点，并`激活`这些节点。如果任何新的部分实例被创建，他们被添加到相应的beta存储区然后
被向下传递到网络的beta部分，激活其它的节点。每当传递达到网络的最底层，它表明一条规则的条件被完全匹配到。这个通常靠
在网络底层定义一个规则（p-node）的特殊节点来实现。每当p-node被激活，它意味着一个新的发现匹配完成（在一些系统相关的方法）。

Rete算法的大部分代码是由处理各种节点激活的程序组成。一个alpha存储区节点的激活靠添加一个给定的WME到存储区来处理，然后传递
WME到存储区的继承者（Join节点会连接它）。相似地，beta存储区节点的激活靠添加一个给定的token到存储区来处理然后把它传递到该
节点的子节点（join节点）。总的来说，beta网络中从一个节点到另外一个节点的激活被称作`左激活`（left activation），来自alpha
存储区的节点的激活被称作`右激活`（right activation）。因此，一个join节点能够招致两种类型的激活：当一个WME被添加到它的alpha
存储区的右激活，和一个token被添加到beta存储区的左激活。左右join节点激活通常在两个不同的程序里实现，但在这两种情况下，都搜索
节点的其它存储区是否存在和新元素有同样变量绑定的元素，如果有发现，它们将被传向join节点的子节点。

为了激活一个给定的节点，那么我们使用的一个程序调用。
 